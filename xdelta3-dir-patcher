#!/usr/bin/env python3
#
#    xdelta3-dir-patcher
#    Copyright (C) 2014-2015 Endless Mobile
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public
#   License as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this library; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
#   USA

import argparse
import tarfile
import zipfile
import random
import logging
import time
import threading
import multiprocessing
import concurrent.futures

from stat import *
from filecmp import dircmp
from sys import stderr, stdout
from tempfile import mkdtemp
from subprocess import check_output, STDOUT
from shutil import copymode, copystat, copyfile, copy2, rmtree, copytree
from os import chmod, chown, cpu_count, geteuid, listdir, makedirs, mkdir
from os import O_NOFOLLOW, O_RDONLY, path, readlink, remove, rmdir, symlink, sep
from os import stat, walk

from os import open as os_open #Prevent mangling the regular open()

VERSION='0.6'

# Allows for invoking attributes as methods/functions
class AttributeDict(dict):
    def __getattr__(self, attr):
        return self[attr]
    def __setattr__(self, attr, value):
        self[attr] = value

# ---------------------------- PROCESS RUNNER ----------------------------
class ExecutorRunner(object):
    def __init__(self, debug = False):
        # multiprocessing.log_to_stderr(logging.DEBUG)

        self.futures = []
        self.start_time = None
        thread_count = max(cpu_count() - 1, 1)

        self.debug = debug

        self.executor = concurrent.futures.ThreadPoolExecutor(thread_count)

    def _fix_terminal(self):
        stdout.flush()
        print()

    def add_task(self, target_func, target_func_args):
        if self.start_time == None:
            self.start_time = time.time()

        self.futures.append(self.executor.submit(target_func, *target_func_args))

        # XXX: For single-threaded debugging
        # target_func(*target_func_args)

    def join_all(self):
        if self.debug:
            # Make sure that the terminal isn't in some strange state
            self._fix_terminal()

            print('Waiting for tasks to finish...')

        # Prevent further scheduling
        self.executor.shutdown(False)

        for future in concurrent.futures.as_completed(self.futures):
            if future.exception():
                raise future.exception()

        # Leftover runners might have again clobbered the output
        self._fix_terminal()

        # XXX: If nothing was ran, we might not have a start time
        if not self.start_time:
            self.start_time = time.time()

        print('Runner time: %.2fs' % (time.time() - self.start_time))

# ---------------------------- ARCHIVE ADAPTERS ----------------------------
class XDeltaArchive(object):
    def __init__(self, archive_path):
        self.archive_object = XDeltaArchive.get_archive_instance(archive_path)

    def __enter__(self):
        return self.archive_object

    def __exit__(self, exc_type, exc_value, traceback):
        self.archive_object.close()

    @staticmethod
    def get_archive_instance(archive_path):
        for clazz in XDelta3AbstractArchiveImpl.__subclasses__():
            if clazz.can_open(archive_path):
                return clazz(archive_path)

        raise RuntimeError('Error! Archive %s bad or not supported!' % archive_path)

class XDelta3AbstractArchiveImpl(object):
    def __init__(self):
        self.lock = threading.RLock()

    def _acquire_lock(self):
        self.lock.acquire()

    def _release_lock(self):
        self.lock.release()

class XDelta3FsImpl(XDelta3AbstractArchiveImpl):
    def __init__(self, path, for_writing = False):
        super().__init__()

        self.path = path
        self.items = None

    # Placeholders to allow us to use 'with` keywords on this implementation
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def close(self):
        pass

    @staticmethod
    def can_open(archive):
        return path.isdir(archive)

    def list_files(self):
        if self.items:
            return self.items

        print('FS: Gathering filelist')
        items = []
        for root, dirs, filenames in walk(self.path):
            for directory in dirs:
                absolute_path = path.join(root, directory)

                # Strip prefix so the files look relative
                relative_path = path.relpath(absolute_path, self.path) + path.sep

                items.append(relative_path)

            for filename in filenames:
                absolute_path = path.join(root, filename)

                # Strip prefix so the files look relative
                relative_path = path.relpath(absolute_path, self.path)

                items.append(relative_path)

        print('FS: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        target_path = path.join(extraction_path, filename)
        source_path = path.join(self.path, filename)

        if not target_path.endswith(path.sep):
            dir_path = path.dirname(target_path)
            makedirs(dir_path, exist_ok = True)

            copy2(source_path, target_path, follow_symlinks = False)
        else:
            makedirs(target_path, exist_ok = True)

            # TODO: Test me
            # Ensure that permissions/ids are transferred along to the target
            copymode(source_path, target_path)
            copystat(source_path, target_path)

            try:
                uid = stat(source_path).st_uid
                gid = stat(source_path).st_gid

                chown(target_path,uid,gid)
            except PermissionError as pe:
                # XXX: We can't copy the uid/gid unless we're run as root
                #      which means that in most cases we can't get that 
                #      included in the diffs unless we add direct linkage
                #      between archive<->archive to copy these values

                # print('WARNING! Could not change uid/gid of', target_path)
                pass

    def create(self, base_dir):
        if path.isdir(self.path):
            raise Exception('Error! Archive already present!')

        copytree(base_dir, self.path,
                 ignore_dangling_symlinks = False)

class XDelta3TarImpl(XDelta3AbstractArchiveImpl):
    TAR_FORMAT = 'gz'

    def __init__(self, archive_path, for_writing = False):
        super().__init__()

        self.items = None
        flags = 'r:*'

        if for_writing:
            if path.isfile(archive_path):
                raise Exception('Error! Archive already present!')

            flags = 'w:%s' % self.TAR_FORMAT

        self.archive_object = tarfile.open(archive_path, flags)

    def _close_archive(self):
        self.archive_object.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._close_archive()

    def close(self):
        self._close_archive()

    @staticmethod
    def can_open(archive):
        return path.isfile(archive) and tarfile.is_tarfile(archive)

    def list_files(self):
        if self.items:
            return self.items

        items = []

        print('Tar: Gathering filelist')
        members = self.archive_object.getmembers()

        # Lookup all member objects
        for member in members:
            # For directories, add a separator to the end
            suffix = path.sep if member.isdir() else ''

            items.append('%s%s' % (member.name, suffix))

        # Append any directories that weren't part of the archive
        for item in items:
            dir_name = path.dirname(item) + path.sep
            if len(dir_name) > 1 and not dir_name in items:
                print('Post-adding %s to members' % dir_name)
                items.append(dir_name)

        print('Tar: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        try:
            extraction_name = filename

            # TODO: Test me
            if filename.endswith(path.sep):
                extraction_name = extraction_name.rstrip(path.sep)

            member = self.archive_object.getmember(extraction_name)
        except KeyError as key_error:
            # Maybe we have a folder that was added to
            # the filelist that isn't really not in the archive
            if filename.endswith(path.sep):
                folder_path = path.join(extraction_path,
                                        filename)

                print('Skiping', folder_path)

                makedirs(folder_path, exist_ok = True)

                return

        makedirs(extraction_path, exist_ok = True)

        # XXX: Not thread safe http://bugs.python.org/issue23649
        try:
            super()._acquire_lock()

            self.archive_object.extract(member, extraction_path)

            super()._release_lock()
        except FileExistsError as fee:
            # XXX tarfile also might have thread issues even with the lock
            #     in place so if we get errors as reported on the bugtracker
            #     (http://bugs.python.org/issue23649) we try to re-run the task.
            # TODO: Test this (somehow)
            super()._release_lock()

            self.expand(filename, extraction_path)
        except Exception as e:
            super()._release_lock()

            raise(e)

    def create(self, base_dir):
        for item in listdir(base_dir):
            item_path = path.join(base_dir, item)
            self.archive_object.add(item_path, item)

class XDelta3ZipImpl(XDelta3AbstractArchiveImpl):
    def __init__(self, archive_path, for_writing = False):
        super().__init__()

        self.items = None

        flags = 'r'

        if for_writing:
            if path.isfile(archive_path):
                raise Exception('Error! Archive already present!')

            flags = 'w'

        self.archive_object = zipfile.ZipFile(archive_path, flags)

    def _close_archive(self):
        self.archive_object.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._close_archive()

    def close(self):
        self._close_archive()

    @staticmethod
    def can_open(archive):
        return path.isfile(archive) and zipfile.is_zipfile(archive)

    def list_files(self):
        if self.items:
            return self.items

        print('Zip: Gathering filelist')
        items = self.archive_object.namelist()
        print('Zip: Gathering completed')

        # Intentional separation of variables so that we don't assign
        # some garbage value to self.items as well as print out the debug
        # messages
        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        makedirs(extraction_path, exist_ok = True)

        self.archive_object.extract(filename, extraction_path)

    def create(self, base_dir):
        for root, dirnames, filenames in walk(base_dir):
            for filename in filenames:
                full_path = path.join(root, filename)
                internal_path = full_path[len(base_dir) + 1:]

                self.archive_object.write(full_path, internal_path)

# ---------------------------- XDELTA3 ADAPTER ----------------------------
class XDelta3Impl(object):
    # TODO: Unit test me
    @staticmethod
    def run_command(args, exec_method = check_output):
        exec_method(args, stderr=STDOUT)

    # TODO: Test me
    @staticmethod
    def diff(old_file, new_file, target_file, debug = False):
        command = ['xdelta3', '-f', '-e']
        if old_file:
            command.append('-s')
            command.append(old_file)

        command.append(new_file)
        command.append(target_file)

        if debug:
            print("Generating xdelta: %s" % command)
            stdout.flush()

        XDelta3Impl.run_command(command)

    # TODO: Test me
    @staticmethod
    def apply(old_file, patch_file, target_file, debug = False):
        command = ['xdelta3', '-f', '-d']
        if old_file:
            command.append('-s')
            command.append(old_file)

        command.append(patch_file)
        command.append(target_file)

        if debug:
            print("Applying xdelta: %s" % command)
            stdout.flush()

        XDelta3Impl.run_command(command)

# ---------------------------- MAIN CLASS ----------------------------
class XDelta3DirPatcher(object):
    PATCH_FOLDER = 'xdelta'
    METADATA_FILE = '.info'

    def __init__(self, args, delta_impl = XDelta3Impl):
        self.args = args
        self.delta_impl = delta_impl

    # TODO: Unit test me
    def copy_attributes(self, src_file, dest_file):
        if self.args.verbose: print("Copying file metadata:", dest_file)
        copymode(src_file, dest_file)
        copystat(src_file, dest_file)

        uid = stat(src_file).st_uid
        gid = stat(src_file).st_gid

        chown(dest_file,uid,gid)

    @staticmethod
    def _get_temp_dir(staging_dir, prefix):
        temp_dir = None
        if staging_dir:
            folder_name = '%s_%s' % (prefix, XDelta3DirPatcher.get_random_string())
            temp_dir = path.join(staging_dir, folder_name)
        else:
            # Create a temp dir if one isn't specified
            temp_dir = mkdtemp(prefix="%s_" % XDelta3DirPatcher.__name__)

        if not path.isdir(temp_dir):
            mkdir(temp_dir)

        return temp_dir

    def _find_file_delta(self, filename, old_archive_obj, new_archive_obj,
                          old_root,
                          new_root,
                          target_root):
        if self.args.debug:
            print("Processing %s" % filename)
        else:
            print('#', end = "")
        stdout.flush()

        new_archive_obj.expand(filename, new_root)

        if filename in old_archive_obj.list_files():
            old_archive_obj.expand(filename, old_root)

        old_path = path.join(old_root, filename)
        new_path = path.join(new_root, filename)
        target_path = path.join(target_root, filename)

        target_dir = path.dirname(target_path)
        makedirs(target_dir, exist_ok = True)

        if self.args.debug: print([old_path, new_path, target_path])

        if path.islink(new_path):
            new_dst = readlink(new_path)
            symlink(new_dst, target_path)
            if self.args.debug: print("symlink: ", [target_path, new_dst])

        elif path.isdir(new_path):
            if not path.exists(target_path):
                mkdir(target_path)
            self.copy_attributes(new_path, target_path)

        else:
            # Regular file
            if not path.isfile(old_path):
                old_path = None
                if self.args.debug: print("Old file not present. Ignoring source in XDelta")

            self.delta_impl.diff(old_path, new_path, target_path, self.args.debug)

            self.copy_attributes(new_path, target_path)

        # Remove each individual file as they're processed
        # to reduce needed size on-disk
        for item in [old_path, new_path]:
            if item and (path.isfile(item) or path.islink(item)):
                remove(item)

    def _apply_file_delta(self, archive_object, patch_file, old_root,
                          target_root,
                          delta_patch_root,
                          staging_dir):
        if self.args.debug:
            print("Processing %s" % patch_file)
        else:
            print('#', end = "")
        stdout.flush()

        archive_object.expand(patch_file, staging_dir)

        rel_path = path.relpath(patch_file, delta_patch_root)
        old_path = path.join(old_root, rel_path)
        patch_path = path.join(staging_dir, patch_file)
        target_path = path.join(target_root, rel_path)

        if args.debug: print([old_path, patch_path, target_path])

        if path.islink(patch_path):
            patch_dst = readlink(patch_path)
            symlink(patch_dst, target_path)
            if args.debug: print("symlink: ", [target_path, patch_dst])

        elif path.isdir(patch_path):
            makedirs(target_path, exist_ok = True)
            self.copy_attributes(patch_path, target_path)

        else:
            # Regular file
            if not path.isfile(old_path):
                old_path = None
                if args.debug: print("Old file not present. Ignoring source in XDelta")

            self.delta_impl.apply(old_path, patch_path, target_path, self.args.debug)

            self.copy_attributes(patch_path, target_path)

            remove(patch_path)

    # TODO: Unit test me
    def diff(self, old_dir, new_dir, patch_bundle, metadata = None,
             staging_dir = None,
             runner = ExecutorRunner()):
        target_dir = self._get_temp_dir(staging_dir, 'target')

        print("Using %s as staging area" % target_dir)
        stdout.flush()

        delta_target_dir = path.join(target_dir, self.PATCH_FOLDER)
        if not path.isdir(delta_target_dir):
            mkdir(delta_target_dir)

        with XDeltaArchive(old_dir) as old_archive_obj, \
             XDeltaArchive(new_dir) as new_archive_obj:
            old_staging_dir = self._get_temp_dir(staging_dir, 'old_src')
            new_staging_dir = self._get_temp_dir(staging_dir, 'new_src')

            # XXX: Preload old archive file list to avoid concurrency issues
            # TODO: Make the listing thread-safe
            old_archive_obj.list_files()

            for filename in new_archive_obj.list_files():
                if self.args.debug:
                    print('Processing %s' % filename)
                else:
                    print('.', end = "")

                runner.add_task(self._find_file_delta, (filename,
                                                        old_archive_obj,
                                                        new_archive_obj,
                                                        old_staging_dir,
                                                        new_staging_dir,
                                                        delta_target_dir))

            # Wait until we diffed everything
            runner.join_all()

        # FIXME: Figure out how to handle dirs (premissions/uids/etc)

        rmtree(old_staging_dir)
        rmtree(new_staging_dir)

        print("\nWriting archive...")
        with tarfile.open(patch_bundle, 'w:gz', format=tarfile.GNU_FORMAT) as patch_archive:
            patch_archive.add(delta_target_dir, arcname=self.PATCH_FOLDER)

            if metadata:
                print("Adding metadata (.info)")
                patch_archive.add(metadata, arcname=self.METADATA_FILE)

        print("Cleaning up...")
        rmtree(target_dir)

        print("Done")

    # XXX This implementation requires directories passed in to be
    #     empty. Callers are required to send in files first if they
    #     expect a mixture of dirs/files of the same path.
    @staticmethod
    def remove_item(target_dir, deleted_item, debug = False, attempt = 0):
        deleted_item_path = path.join(target_dir, deleted_item)
        if debug:
            print('Deleting %s' % deleted_item_path)
        else:
            print('X', end = "")

        if not path.exists(deleted_item_path):
            return

        if path.isdir(deleted_item_path):
            # XXX: Try again a couple of seconds if concurrent threads have
            #      not removed the internal files within the directory yet and
            #      raise the errors otherwise. The approach is a bit strange but
            #      it allows us for multi-threaded removal, prevents usage of
            #      rmtree, and will fail properly if it's a real OSError
            try:
                rmdir(deleted_item_path)
            except OSError as ose:
                if cpu_count() < 2 or attempt > 8:
                    raise ose

                time.sleep(0.2)

                attempt += 1
                XDelta3DirPatcher.remove_item(target_dir, deleted_item, debug, attempt)
        else:
            remove(deleted_item_path)

    # TODO: Unit test me
    def apply(self, old_dir, patch_bundle, target_dir, root_patch_dir = None,
              staging_dir = None,
              runner = ExecutorRunner()):
        in_place_apply = old_dir == target_dir

        # TODO: Test me
        # Create a temp dir
        patch_staging_dir = self._get_temp_dir(staging_dir, 'delta_expanded')
        print("Using %s as staging area" % patch_staging_dir)

        # If we want to apply only a part of the xdelta files
        # from withing the delta bundle xdelta/ folder
        if not root_patch_dir:
            delta_patch_root = self.PATCH_FOLDER
        else:
            delta_patch_root = path.join(self.PATCH_FOLDER, root_patch_dir)

        # Make target dir if we don't have one
        if not path.isdir(target_dir):
            print("WARNING: Target directory not present so it will be created.")
            print("  - Please ensure that the toplevel target dir has the correct permissions.")
            makedirs(target_dir)

        print('Enumerating old files')
        old_files = []
        with XDeltaArchive(old_dir) as old_archive:
            old_files = old_archive.list_files()
        if self.args.verbose: print("Old: %s" % old_files)

        print('Applying patches from %s' % patch_bundle)
        with XDeltaArchive(patch_bundle) as patch_archive:
            all_archive_items = patch_archive.list_files()
            if self.args.verbose: print("All in patch: %s" % all_archive_items)

            patches = [p for p in all_archive_items if p.startswith(delta_patch_root)]
            if self.args.verbose: print("Patches: %s" % patches)

            # XXX: We need to strip out the internal path prefix on the patches
            #      to be able to compare the file lists and build a "to_remove"
            #      array. The reason why we use len() vs path.relpath() is so that
            #      we don't strip out the trailing path.sep() on directories that
            #      relpath does automatically
            files_in_patch = []
            for filename in patches:
                relative_filename = filename[len(delta_patch_root) + len(path.sep):]
                files_in_patch.append(relative_filename)

            if self.args.verbose: print("In patch: %s" % files_in_patch)

            removed_items = [f for f in old_files if f not in files_in_patch]

            # XXX: This is to ensure that we never try to remove a directory while
            #      all of its children are in queue waiting for a thread (causing
            #      a deadlock)
            removed_items.sort(key=len, reverse=True)

            if self.args.verbose: print("Removed: %s" % removed_items)

            print("Removing deleted files")

            for removed_item in removed_items:
                if self.args.debug:
                    print('Queueing deletion %s' % filename)
                else:
                    print('x', end = "")

                runner.add_task(self.remove_item, (target_dir,
                                                   removed_item,
                                                   self.args.debug))

            for patch in patches:
                if self.args.debug:
                    print('Queueing %s' % patch)
                else:
                    print('.', end = "")

                runner.add_task(self._apply_file_delta, (patch_archive,
                                                         patch,
                                                         old_dir,
                                                         target_dir,
                                                         delta_patch_root,
                                                         patch_staging_dir))
            runner.join_all()

        print("Cleaning up")
        rmtree(patch_staging_dir)

        print("Done")

    @staticmethod
    def check_euid(ignore_euid, get_euid_method = geteuid):
        if (not ignore_euid) and get_euid_method() != 0:
            stderr.write("ERROR: You must be root to apply the delta! Exiting.\n")
            raise Exception()

    @staticmethod
    def get_random_string(length = 8):
        return ''.join([random.choice('0123456789abcdef') for i in range(length)])

    def run(self):
        print("Running directory patcher...")

        if self.args.action == 'diff':
            if self.args.debug: print("Parsing arguments")

            print("Generating delta pack")
            self.diff(self.args.old_version,
                      self.args.new_version,
                      self.args.patch_bundle,
                      self.args.metadata,
                      self.args.staging_dir)
        else:
            # If we're not the root user, bail since we can't ensure that the
            # user and group permissions are retained
            self.check_euid(self.args.ignore_euid)

            # If no target dir specified, assume in-place update
            if not self.args.target_dir:
                self.args.target_dir = self.args.old_dir

            print("Applying delta pack")
            self.apply(self.args.old_dir, self.args.patch_bundle,
                       self.args.target_dir,
                       self.args.root_patch_dir,
                       self.args.staging_dir)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Creates and applies XDelta3-based directory diff tgz files')

    subparsers = parser.add_subparsers(dest='action')
    parser_apply = subparsers.add_parser('apply',
            help='Apply a diff from a directory. See "apply -help" for more options')

    parser_diff = subparsers.add_parser('diff',
            help='Generate a diff from directories/files. See "diff -help" for more options')

    # Arguments to apply a diff
    parser_apply.add_argument('old_dir',
            help='Folder containing the old version of the files')

    parser_apply.add_argument('patch_bundle',
            help='File containing the patches')

    parser_apply.add_argument('target_dir',
            nargs='?',
            default=None,
            help='Destination folder for the new versions of files')

    parser_apply.add_argument('-d', '--root-patch-dir',
            nargs='?',
            default=None,
            help='Root directory from the diff bundle from where to apply \
                  the patches')

    parser_apply.add_argument('--ignore-euid',
            help='Disable checking of EUID on applying the patch',
            default=False,
            action='store_true')

    # Arguments to create a diff
    parser_diff.add_argument('-m', '--metadata',
            nargs='?',
            default=None,
            help='Add this file (renamed to .info) as metadata to the diff')

    parser_diff.add_argument('old_version',
            help='Folder or tgz containing the old version of the files')

    parser_diff.add_argument('new_version',
            help='Folder or tgz containing the new version of the files')

    parser_diff.add_argument('patch_bundle',
            help='Destination path for the generated patch diff')

    # Generic arguments
    parser.add_argument('-s', '--staging-dir',
            nargs='?',
            default=None,
            help='Use this directory for all staging output of this program. Defaults to /tmp.')

    parser.add_argument('--debug',
            help='Enable debugging output',
            action='store_true')

    parser.add_argument('--verbose',
            help='Enable extremely verbose debugging output',
            action='store_true')

    parser.add_argument('--version',
            action='version',
            version='%(prog)s v' + VERSION)

    args = AttributeDict(vars(parser.parse_args()))

    if args.verbose:
        args.debug = True

    if args.action:
        XDelta3DirPatcher(args).run()
    else:
        parser.print_help()
