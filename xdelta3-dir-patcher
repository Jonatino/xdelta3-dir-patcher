#!/usr/bin/env python3
#
#    xdelta3-dir-patcher
#    Copyright (C) 2014-2015 Endless Mobile
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public
#   License as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this library; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
#   USA

import argparse
import tarfile
import zipfile
import random
import logging
import time
import threading
import multiprocessing
import concurrent.futures

from stat import *
from filecmp import dircmp
from sys import stderr, stdout
from tempfile import mkdtemp
from subprocess import check_output, STDOUT
from shutil import copymode, copystat, copyfile, copy2, rmtree, copytree
from os import chmod, chown, cpu_count, geteuid, listdir, makedirs, mkdir
from os import path, readlink, remove, symlink, sep, stat, walk

VERSION='0.6'

# Allows for invoking attributes as methods/functions
class AttributeDict(dict):
    def __getattr__(self, attr):
        return self[attr]
    def __setattr__(self, attr, value):
        self[attr] = value

# ---------------------------- PROCESS RUNNER ----------------------------
class ExecutorRunner(object):
    def __init__(self, debug = False):
        # multiprocessing.log_to_stderr(logging.DEBUG)

        self.futures = []
        self.start_time = None
        thread_count = max(cpu_count() - 1, 1)

        self.debug = debug

        self.executor = concurrent.futures.ThreadPoolExecutor(thread_count)

    def _fix_terminal(self):
        stdout.flush()
        print()

    def add_task(self, target_func, target_func_args):
        if self.start_time == None:
            self.start_time = time.time()

        self.futures.append(self.executor.submit(target_func, *target_func_args))

    def join_all(self):
        if self.debug:
            # Make sure that the terminal isn't in some strange state
            self._fix_terminal()

            print('Waiting for tasks to finish...')

        # Prevent further scheduling
        self.executor.shutdown(False)

        for future in concurrent.futures.as_completed(self.futures):
            if future.exception():
                raise future.exception()

        # Leftover runners might have again clobbered the output
        self._fix_terminal()

        print('Runner time: %.2fs' % (time.time() - self.start_time))

# ---------------------------- ARCHIVE ADAPTERS ----------------------------
class XDeltaArchive(object):
    def __init__(self, archive_path):
        self.archive_object = XDeltaArchive.get_archive_instance(archive_path)

    def __enter__(self):
        return self.archive_object

    def __exit__(self, exc_type, exc_value, traceback):
        self.archive_object.close()

    @staticmethod
    def get_archive_instance(archive_path):
        for clazz in XDelta3AbstractArchiveImpl.__subclasses__():
            if clazz.can_open(archive_path):
                return clazz(archive_path)

        raise RuntimeError('Error! Archive %s bad or not supported!' % archive_path)

class XDelta3AbstractArchiveImpl(object):
    def __init__(self):
        self.lock = threading.Lock()

    def _safe_makedirs(self, dir_path):
        try:
            # FIXME: Copy all permissions for these if needed
            makedirs(dir_path)
        # Concurrency problems need to be handled. If two threads create
        # the same dir, there might be a race between them checking and
        # doing makedirs so we handle that "gracefully" here.
        except FileExistsError as fee:
            if not path.isdir(dir_path):
                raise fee

    def _acquire_lock(self):
        self.lock.acquire()

    def _release_lock(self):
        self.lock.release()

class XDelta3FsImpl(XDelta3AbstractArchiveImpl):
    def __init__(self, path):
        super().__init__()

        self.path = path
        self.items = None

    # Placeholders to allow us to use 'with` keywords on this implementation
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def close(self):
        pass

    @staticmethod
    def can_open(archive):
        return path.isdir(archive)

    def list_files(self):
        if self.items:
            return self.items

        print('FS: Gathering filelist')
        items = []
        for root, dirs, filenames in walk(self.path):
            for directory in dirs:
                absolute_path = path.join(root, directory)

                # Strip prefix so the files look relative
                relative_path = path.relpath(absolute_path, self.path) + path.sep

                items.append(relative_path)

            for filename in filenames:
                absolute_path = path.join(root, filename)

                # Strip prefix so the files look relative
                relative_path = path.relpath(absolute_path, self.path)

                items.append(relative_path)

        print('FS: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        target_path = path.join(extraction_path, filename)

        if not target_path.endswith(path.sep):
            dir_path = path.dirname(target_path)
            super()._safe_makedirs(dir_path)

            copy2(path.join(self.path, filename), target_path,
                  follow_symlinks=False)
        else:
            super()._safe_makedirs(target_path)

    def create(self, base_dir):
        if path.isdir(self.path):
            raise Exception('Error! Archive already present!')

        copytree(base_dir, self.path,
                 ignore_dangling_symlinks=False)

class XDelta3TarImpl(XDelta3AbstractArchiveImpl):
    TAR_FORMAT = 'gz'

    def __init__(self, archive_path, for_writing = False):
        super().__init__()

        self.items = None
        flags = 'r:*'

        if for_writing:
            if path.isfile(archive_path):
                raise Exception('Error! Archive already present!')

            flags = 'w:%s' % self.TAR_FORMAT

        self.archive_object = tarfile.open(archive_path, flags)

    def _close_archive(self):
        self.archive_object.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._close_archive()

    def close(self):
        self._close_archive()

    @staticmethod
    def can_open(archive):
        return path.isfile(archive) and tarfile.is_tarfile(archive)

    def list_files(self):
        if self.items:
            return self.items

        items = []

        print('Tar: Gathering filelist')
        members = self.archive_object.getmembers()

        # Lookup all member objects
        for member in members:
            # For directories, add a separator to the end
            suffix = path.sep if member.isdir() else ''

            items.append('%s%s' % (member.name, suffix))

        # Append any directories that weren't part of the archive
        for item in items:
            dir_name = path.dirname(item) + path.sep
            if len(dir_name) > 1 and not dir_name in items:
                print('Post-adding %s to members' % dir_name)
                items.append(dir_name)

        print('Tar: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        try:
            member = self.archive_object.getmember(filename)
        except KeyError as key_error:
            # Maybe we have a folder that was added to
            # the filelist that isn't really ni the archive
            if filename.endswith(path.sep):
                folder_path = path.join(extraction_path,
                                        filename)

                super()._safe_makedirs(folder_path)

                return

        super()._safe_makedirs(extraction_path)

        # XXX: Not thread safe
        super()._acquire_lock()
        self.archive_object.extract(member, extraction_path)
        super()._release_lock()

    def create(self, base_dir):
        for item in listdir(base_dir):
            full_path = path.join(base_dir, item)
            self.archive_object.add(full_path, item)

class XDelta3ZipImpl(XDelta3AbstractArchiveImpl):
    def __init__(self, archive_path, for_writing = False):
        super().__init__()

        self.items = None

        flags = 'r'

        if for_writing:
            if path.isfile(archive_path):
                raise Exception('Error! Archive already present!')

            flags = 'w'

        self.archive_object = zipfile.ZipFile(archive_path, flags)

    def _close_archive(self):
        self.archive_object.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._close_archive()

    def close(self):
        self._close_archive()

    @staticmethod
    def can_open(archive):
        return path.isfile(archive) and zipfile.is_zipfile(archive)

    def list_files(self):
        if self.items:
            return self.items

        print('Zip: Gathering filelist')
        items = self.archive_object.namelist()
        print('Zip: Gathering completed')

        # Intentional separation of variables so that we don't assign
        # some garbage value to self.items as well as print out the debug
        # messages
        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        super()._safe_makedirs(extraction_path)

        self.archive_object.extract(filename, extraction_path)

    def create(self, base_dir):
        for root, dirnames, filenames in walk(base_dir):
            for filename in filenames:
                full_path = path.join(root, filename)
                internal_path = full_path[len(base_dir) + 1:]

                self.archive_object.write(full_path, internal_path)

# ---------------------------- XDELTA3 ADAPTER ----------------------------
class XDelta3Impl(object):
    # TODO: Unit test me
    @staticmethod
    def run_command(args, exec_method = check_output):
        exec_method(args, stderr=STDOUT)

    # TODO: Test me
    @staticmethod
    def diff(old_file, new_file, target_file, debug = False):
        command = ['xdelta3', '-f', '-e']
        if old_file:
            command.append('-s')
            command.append(old_file)

        command.append(new_file)
        command.append(target_file)

        if debug: print("Generating xdelta: %s" % command)
        XDelta3Impl.run_command(command)

    # TODO: Test me
    @staticmethod
    def apply(old_file, patch_file, target_file, debug = False):
        command = ['xdelta3', '-f', '-d']
        if old_file:
            command.append('-s')
            command.append(old_file)

        command.append(patch_file)
        command.append(target_file)

        if debug: print("Applying xdelta: %s" % command)
        XDelta3Impl.run_command(command)

# ---------------------------- MAIN CLASS ----------------------------
class XDelta3DirPatcher(object):
    PATCH_FOLDER = 'xdelta'
    METADATA_FILE = '.info'

    def __init__(self, args, delta_impl = XDelta3Impl):
        self.args = args
        self.delta_impl = delta_impl

    # TODO: Unit test me
    def copy_attributes(self, src_file, dest_file):
        if self.args.debug: print("Copying mode data")
        copymode(src_file, dest_file)

        if self.args.debug: print("Copying stat data (sans UID/GID)")
        copystat(src_file, dest_file)

        if self.args.debug: print("Copying UID & GID")
        uid = stat(src_file).st_uid
        gid = stat(src_file).st_gid

        chown(dest_file,uid,gid)

    @staticmethod
    def _safe_makedirs(dir_path):
        try:
            makedirs(dir_path)
        # Concurrency problems need to be handled. If two threads create
        # the same dir, there might be a race between them checking and
        # doing makedirs so we handle that "gracefully" here.
        except FileExistsError as fee:
            if not path.isdir(dir_path):
                raise fee

    @staticmethod
    def _get_temp_dir(staging_dir, prefix):
        temp_dir = None
        if staging_dir:
            folder_name = '%s_%s' % (prefix, XDelta3DirPatcher.get_random_string())
            temp_dir = path.join(staging_dir, folder_name)
        else:
            # Create a temp dir if one isn't specified
            temp_dir = mkdtemp(prefix="%s_" % XDelta3DirPatcher.__name__)

        if not path.isdir(temp_dir):
            mkdir(temp_dir)

        return temp_dir

    def _find_file_delta(self, filename, old_archive_obj, new_archive_obj,
                          old_root,
                          new_root,
                          target_root):
        if self.args.debug:
            print("Processing %s" % filename)
        else:
            print('#', end = "")
        stdout.flush()

        new_archive_obj.expand(filename, new_root)

        if filename in old_archive_obj.list_files():
            old_archive_obj.expand(filename, old_root)

        old_path = path.join(old_root, filename)
        new_path = path.join(new_root, filename)
        target_path = path.join(target_root, filename)

        target_dir = path.dirname(target_path)
        XDelta3DirPatcher._safe_makedirs(target_dir)

        if self.args.debug: print([old_path, new_path, target_path])

        if path.islink(new_path):
            new_dst = readlink(new_path)
            symlink(new_dst, target_path)
            if self.args.debug: print("symlink: ", [target_path, new_dst])

        elif path.isdir(new_path):
            if not path.exists(target_path):
                mkdir(target_path)
            self.copy_attributes(new_path, target_path)

        else:
            # Regular file
            if not path.isfile(old_path):
                old_path = None
                if self.args.debug: print("Old file not present. Ignoring source in XDelta")

            self.delta_impl.diff(old_path, new_path, target_path, self.args.debug)

            self.copy_attributes(new_path, target_path)

        # Remove each individual file as they're processed
        # to reduce needed size on-disk
        for item in [old_path, new_path]:
            if item and (path.isfile(item) or path.islink(item)):
                remove(item)

    def _apply_file_delta(self, rel_path, patch_file, old_root, patch_root, target_root):
        print("Processing %s" % patch_file)

        if not path.isdir(target_root):
            makedirs(target_root)

        old_path = path.join(old_root, rel_path, patch_file)
        patch_path = path.join(patch_root, rel_path, patch_file)
        target_path = path.join(target_root, rel_path, patch_file)

        if args.debug: print([old_path, patch_path, target_path])

        if path.islink(patch_path):
            patch_dst = readlink(patch_path)
            symlink(patch_dst, target_path)
            if args.debug: print("symlink: ", [target_path, patch_dst])

        elif path.isdir(patch_path):
            if not path.isdir(target_path):
                makedirs(target_path)
            self.copy_attributes(patch_path, target_path)

        else:
            # Regular file
            if not path.isfile(old_path):
                old_path = None
                if args.debug: print("Old file not present. Ignoring source in XDelta")

            self.delta_impl.apply(old_path, patch_path, target_path, self.args.debug)

            self.copy_attributes(patch_path, target_path)

    # TODO: Unit test me
    def diff(self, old_dir, new_dir, patch_bundle, metadata = None,
             staging_dir = None,
             runner = ExecutorRunner()):
        target_dir = self._get_temp_dir(staging_dir, 'target')

        print("Using %s as staging area" % target_dir)
        stdout.flush()

        delta_target_dir = path.join(target_dir, self.PATCH_FOLDER)
        if not path.isdir(delta_target_dir):
            mkdir(delta_target_dir)

        with XDeltaArchive(old_dir) as old_archive_obj, \
             XDeltaArchive(new_dir) as new_archive_obj:
            old_staging_dir = self._get_temp_dir(staging_dir, 'old_src')
            new_staging_dir = self._get_temp_dir(staging_dir, 'new_src')

            # XXX: Preload old archive file list to avoid concurrency issues
            # TODO: Make the listing thread-safe
            old_archive_obj.list_files()

            for filename in new_archive_obj.list_files():
                if filename.endswith('/'):
                    continue

                if self.args.debug:
                    print('Expanding %s' % filename)
                else:
                    print('.', end = "")

                runner.add_task(self._find_file_delta, (filename,
                                                        old_archive_obj,
                                                        new_archive_obj,
                                                        old_staging_dir,
                                                        new_staging_dir,
                                                        delta_target_dir))

            # Wait until we diffed everything
            runner.join_all()

        # FIXME: Figure out how to handle dirs (premissions/uids/etc)

        rmtree(old_staging_dir)
        rmtree(new_staging_dir)

        print("\nWriting archive...")
        with tarfile.open(patch_bundle, 'w:gz', format=tarfile.GNU_FORMAT) as patch_archive:
            patch_archive.add(delta_target_dir, arcname=self.PATCH_FOLDER)

            if metadata:
                print("Adding metadata (.info)")
                patch_archive.add(metadata, arcname=self.METADATA_FILE)

        print("Cleaning up...")
        rmtree(target_dir)

        print("Done")

    def remove_deleted_items(self, target_dir, diff):
        deleted_items = diff.right_only

        for deleted_item in deleted_items:
            deleted_item_path = path.join(target_dir, deleted_item)
            if path.isdir(deleted_item_path):
                rmtree(deleted_item_path)
            else:
                remove(deleted_item_path)

            if self.args.debug: print("Deleted old path", deleted_file)

        for subdir, subdir_diff in zip(diff.common_dirs, diff.subdirs.values()):
            print(subdir)

            self.remove_deleted_items(path.join(target_dir, subdir), subdir_diff)

    # TODO: Unit test me
    def apply(self, old_dir, patch_bundle, target_dir, root_patch_dir = None,
              staging_dir = None,
              runner = ExecutorRunner()):
        # Create a temp dir
        # TODO: Test me
        patch_dir = self._get_temp_dir(staging_dir, 'delta_src')
        print("Using %s as staging area" % patch_dir)

        delta_patch_dir = path.join(patch_dir, self.PATCH_FOLDER)

        # If we want to apply only a part of the xdelta files (or a specific dir)
        if root_patch_dir:
            delta_patch_dir = path.join(delta_patch_dir, root_patch_dir)

        print("Extracting archive...")
        with XDeltaArchive(patch_bundle) as archive_object:
            for filename in archive_object.list_files():
                archive_object.expand(filename, patch_dir)

        # Make target dir if we don't have one
        if not path.isdir(target_dir):
            print("WARNING: Target directory not present so it will be created.")
            print("  - Please ensure that the toplevel target dir has the correct permissions.")
            makedirs(target_dir)

        print("Removing deleted files")
        diff = dircmp(delta_patch_dir, target_dir, ignore = None)
        self.remove_deleted_items(target_dir, diff)

        print("Applying patches")
        for root, patch_dirs, patch_files in walk(delta_patch_dir):
            print("Entering directory", root)

            rel_path = path.relpath(root, delta_patch_dir)

            if self.args.debug: print("- Subdirs:", patch_dirs)
            if self.args.debug: print("- Files:", patch_files)

            for patch_dir1 in patch_dirs:
                self._apply_file_delta(rel_path, patch_dir1, old_dir, delta_patch_dir, target_dir)
            for patch_file in patch_files:
                self._apply_file_delta(rel_path, patch_file, old_dir, delta_patch_dir, target_dir)

            print("Leaving directory", root)

        print("Cleaning up...")
        rmtree(patch_dir)

        print("Done")

    @staticmethod
    def check_euid(ignore_euid, get_euid_method = geteuid):
        if (not ignore_euid) and get_euid_method() != 0:
            stderr.write("ERROR: You must be root to apply the delta! Exiting.\n")
            raise Exception()

    @staticmethod
    def get_random_string(length = 8):
        return ''.join([random.choice('0123456789abcdef') for i in range(length)])

    def run(self):
        print("Running directory patcher...")

        if self.args.action == 'diff':
            if self.args.debug: print("Parsing arguments")

            print("Generating delta pack")
            self.diff(self.args.old_version,
                      self.args.new_version,
                      self.args.patch_bundle,
                      self.args.metadata,
                      self.args.staging_dir)
        else:
            # If we're not the root user, bail since we can't ensure that the
            # user and group permissions are retained
            self.check_euid(self.args.ignore_euid)

            # If no target dir specified, assume in-place update
            if not self.args.target_dir:
                self.args.target_dir = self.args.old_dir

            print("Applying delta pack")
            self.apply(self.args.old_dir, self.args.patch_bundle,
                       self.args.target_dir,
                       self.args.root_patch_dir,
                       self.args.staging_dir)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Creates and applies XDelta3-based directory diff tgz files')

    subparsers = parser.add_subparsers(dest='action')
    parser_apply = subparsers.add_parser('apply',
            help='Apply a diff from a directory. See "apply -help" for more options')

    parser_diff = subparsers.add_parser('diff',
            help='Generate a diff from directories/files. See "diff -help" for more options')

    # Arguments to apply a diff
    parser_apply.add_argument('old_dir',
            help='Folder containing the old version of the files')

    parser_apply.add_argument('patch_bundle',
            help='File containing the patches')

    parser_apply.add_argument('target_dir',
            nargs='?',
            default=None,
            help='Destination folder for the new versions of files')

    parser_apply.add_argument('-d', '--root-patch-dir',
            nargs='?',
            default=None,
            help='Root directory from the diff bundle from where to apply \
                  the patches')

    parser_apply.add_argument('--ignore-euid',
            help='Disable checking of EUID on applying the patch',
            default=False,
            action='store_true')

    # Arguments to create a diff
    parser_diff.add_argument('-m', '--metadata',
            nargs='?',
            default=None,
            help='Add this file (renamed to .info) as metadata to the diff')

    parser_diff.add_argument('old_version',
            help='Folder or tgz containing the old version of the files')

    parser_diff.add_argument('new_version',
            help='Folder or tgz containing the new version of the files')

    parser_diff.add_argument('patch_bundle',
            help='Destination path for the generated patch diff')

    # Generic arguments
    parser.add_argument('-s', '--staging-dir',
            nargs='?',
            default=None,
            help='Use this directory for all staging output of this program. Defaults to /tmp.')

    parser.add_argument('--debug',
            help='Enable debugging output',
            action='store_true')

    parser.add_argument('--version',
            action='version',
            version='%(prog)s v' + VERSION)

    args = AttributeDict(vars(parser.parse_args()))

    if args.action:
        XDelta3DirPatcher(args).run()
    else:
        parser.print_help()
