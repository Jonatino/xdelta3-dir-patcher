#!/usr/bin/env python3

import argparse
import tarfile
import zipfile
import random

from stat import *
from filecmp import dircmp
from sys import stderr
from tempfile import mkdtemp
from subprocess import check_output, STDOUT
from shutil import copymode, copystat, copyfile, copy2, rmtree, copytree
from os import chmod, chown, geteuid, listdir, makedirs, mkdir, path, readlink
from os import remove, symlink, sep, stat, walk

VERSION='0.6'

# Allows for invoking attributes as methods/functions
class AttributeDict(dict):
    def __getattr__(self, attr):
        return self[attr]
    def __setattr__(self, attr, value):
        self[attr] = value

# ---------------------------- ARCHIVE ADAPTERS ----------------------------
class XDelta3FsImpl(object):
    def __init__(self, path):
        self.path = path
        self.items = None

    def list_files(self):
        if self.items:
            return self.items

        print('FS: Gathering filelist')
        items = []
        for root, dirs, filenames in walk(self.path):
            for directory in dirs:
                absolute_path = path.join(root, directory)

                # Strip prefix so the files look relative
                relative_path = path.relpath(absolute_path, self.path) + path.sep

                items.append(relative_path)

            for filename in filenames:
                absolute_path = path.join(root, filename)

                # Strip prefix so the files look relative
                relative_path = path.relpath(absolute_path, self.path)

                items.append(relative_path)

        print('FS: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        target_path = path.join(extraction_path, filename)

        if not target_path.endswith(path.sep):
            dir_path = path.dirname(target_path)
            if not path.isdir(dir_path):
                makedirs(dir_path)

            copy2(path.join(self.path, filename), target_path,
                  follow_symlinks=False)
        else:
            if not path.isdir(target_path):
                makedirs(target_path)


    def create(self, base_dir):
        if path.isdir(self.path):
            raise Exception('Error! Archive already present!')

        copytree(base_dir, self.path,
                 ignore_dangling_symlinks=False)

class XDelta3TarImpl(object):
    TAR_FORMAT = 'gz'

    def __init__(self, archive_path):
        self.archive_path = archive_path
        self.items = None

    def list_files(self):
        if self.items:
            return self.items

        print('Tar: Gathering filelist')
        items = []
        with tarfile.open(self.archive_path) as archive_object:
            members = archive_object.getmembers()

            # Lookup all member objects
            for member in members:
                # For directories, add a separator to the end
                suffix = path.sep if member.isdir() else ''

                items.append('%s%s' % (member.name, suffix))

        # Append any directories that weren't part of the archive
        for item in items:
            dir_name = path.dirname(item) + path.sep
            if len(dir_name) > 1 and not dir_name in items:
                print('Post-adding %s to members' % dir_name)
                items.append(dir_name)

        print('Tar: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        with tarfile.open(self.archive_path) as archive_object:
            try:
                member = archive_object.getmember(filename)
            except KeyError as key_error:
                # Maybe we have a folder that was added to
                # the filelist that isn't really ni the archive
                if filename.endswith(path.sep):
                    folder_path = path.join(extraction_path,
                                            filename)

                    if not path.isdir(folder_path):
                        makedirs(folder_path)

                    return

            if not path.isdir(extraction_path):
                makedirs(extraction_path)

            archive_object.extract(member, extraction_path)

    def create(self, base_dir):
        if path.isfile(self.archive_path):
            raise Exception('Error! Archive already present!')

        with tarfile.open(self.archive_path, 'w:%s' % self.TAR_FORMAT) as archive_object:
            for item in listdir(base_dir):
                full_path = path.join(base_dir, item)
                archive_object.add(full_path, item)

class XDelta3ZipImpl(object):
    def __init__(self, archive_path):
        self.archive_path = archive_path
        self.items = None

    def list_files(self):
        if self.items:
            return self.items

        print('Zip: Gathering filelist')
        items = []
        with zipfile.ZipFile(self.archive_path, 'r') as archive_object:
            items = archive_object.namelist()

        print('Zip: Gathering completed')

        self.items = items

        return self.items

    def expand(self, filename, extraction_path):
        if not path.isdir(extraction_path):
            makedirs(extraction_path)

        with zipfile.ZipFile(self.archive_path, 'r') as archive_object:
            archive_object.extract(filename, extraction_path)

    def create(self, base_dir):
        if path.isfile(self.archive_path):
            raise Exception('Error! Archive already present!')

        with zipfile.ZipFile(self.archive_path, 'w') as archive_object:
            for root, dirnames, filenames in walk(base_dir):
                for filename in filenames:
                    full_path = path.join(root, filename)
                    internal_path = full_path[len(base_dir) + 1:]

                    archive_object.write(full_path, internal_path)

# ---------------------------- XDELTA3 ADAPTER ----------------------------
class XDelta3Impl(object):
    # TODO: Unit test me
    @staticmethod
    def run_command(args, exec_method = check_output):
        exec_method(args, stderr=STDOUT)

    # TODO: Test me
    @staticmethod
    def diff(old_file, new_file, target_file, debug = False):
        command = ['xdelta3', '-f', '-e']
        if old_file:
            command.append('-s')
            command.append(old_file)

        command.append(new_file)
        command.append(target_file)

        if debug: print("Generating xdelta: %s" % command)
        XDelta3Impl.run_command(command)

    # TODO: Test me
    @staticmethod
    def apply(old_file, patch_file, target_file, debug = False):
        command = ['xdelta3', '-f', '-d']
        if old_file:
            command.append('-s')
            command.append(old_file)

        command.append(patch_file)
        command.append(target_file)

        if debug: print("Applying xdelta: %s" % command)
        XDelta3Impl.run_command(command)

# ---------------------------- MAIN CLASS ----------------------------
class XDelta3DirPatcher(object):
    PATCH_FOLDER = 'xdelta'
    METADATA_FILE = '.info'

    def __init__(self, args, delta_impl = XDelta3Impl):
        self.args = args
        self.delta_impl = delta_impl

    # TODO: Unit test me
    def copy_attributes(self, src_file, dest_file):
        if self.args.debug: print("Copying mode data")
        copymode(src_file, dest_file)

        if self.args.debug: print("Copying stat data (sans UID/GID")
        copystat(src_file, dest_file)

        if self.args.debug: print("Copying UID & GID")
        uid = stat(src_file).st_uid
        gid = stat(src_file).st_gid

        chown(dest_file,uid,gid)

    @staticmethod
    def _get_temp_dir(staging_dir, prefix):
        temp_dir = None
        if staging_dir:
            folder_name = '%s_%s' % (prefix, XDelta3DirPatcher.get_random_string())
            temp_dir = path.join(staging_dir, folder_name)
        else:
            # Create a temp dir if one isn't specified
            temp_dir = mkdtemp(prefix="%s_" % XDelta3DirPatcher.__name__)

        if not path.isdir(temp_dir):
            mkdir(temp_dir)

        return temp_dir

    def _find_file_delta(self, filename, old_root, new_root, target_root):
        print("Processing %s" % filename)

        old_path = path.join(old_root, filename)
        new_path = path.join(new_root, filename)
        target_path = path.join(target_root, filename)

        target_dir = path.dirname(target_path)
        if not path.isdir(target_dir):
            # FIXME: Copy all permissions for these
            makedirs(target_dir)

        if self.args.debug: print([old_path, new_path, target_path])

        if path.islink(new_path):
            new_dst = readlink(new_path)
            symlink(new_dst, target_path)
            if self.args.debug: print("symlink: ", [target_path, new_dst])

        elif path.isdir(new_path):
            if not path.exists(target_path):
                mkdir(target_path)
            self.copy_attributes(new_path, target_path)

        else:
            # Regular file
            if not path.isfile(old_path):
                old_path = None
                if self.args.debug: print("Old file not present. Ignoring source in XDelta")

            self.delta_impl.diff(old_path, new_path, target_path, self.args.debug)

            self.copy_attributes(new_path, target_path)

    def _apply_file_delta(self, rel_path, patch_file, old_root, patch_root, target_root):
        print("Processing %s" % patch_file)

        if not path.isdir(target_root):
            makedirs(target_root)

        old_path = path.join(old_root, rel_path, patch_file)
        patch_path = path.join(patch_root, rel_path, patch_file)
        target_path = path.join(target_root, rel_path, patch_file)

        if args.debug: print([old_path, patch_path, target_path])

        if path.islink(patch_path):
            patch_dst = readlink(patch_path)
            symlink(patch_dst, target_path)
            if args.debug: print("symlink: ", [target_path, patch_dst])

        elif path.isdir(patch_path):
            if not path.isdir(target_path):
                makedirs(target_path)
            self.copy_attributes(patch_path, target_path)

        else:
            # Regular file
            if not path.isfile(old_path):
                old_path = None
                if args.debug: print("Old file not present. Ignoring source in XDelta")

            self.delta_impl.apply(old_path, patch_path, target_path, self.args.debug)

            self.copy_attributes(patch_path, target_path)

    # TODO: Unit test me
    def diff(self, old_dir, new_dir, patch_bundle, metadata = None,
             staging_dir = None):
        target_dir = self._get_temp_dir(staging_dir, 'target')

        print("Using %s as staging area" % target_dir)

        delta_target_dir = path.join(target_dir, self.PATCH_FOLDER)
        if not path.isdir(delta_target_dir):
            mkdir(delta_target_dir)

        old_archive_obj = self.get_archive_instance(old_dir)
        new_archive_obj = self.get_archive_instance(new_dir)

        old_staging_dir = self._get_temp_dir(staging_dir, 'old_src')
        new_staging_dir = self._get_temp_dir(staging_dir, 'new_src')
        for filename in new_archive_obj.list_files():
            new_archive_obj.expand(filename, new_staging_dir)

            if filename in old_archive_obj.list_files():
                old_archive_obj.expand(filename, old_staging_dir)

            self._find_file_delta(filename, old_staging_dir, new_staging_dir, delta_target_dir)

        # FIXME: Figure out how to handle dirs (premissions/uids/etc)

        # TODO: Remove each individual file as they're processed
        rmtree(old_staging_dir)
        rmtree(new_staging_dir)

        print("\nWriting archive...")
        with tarfile.open(patch_bundle, 'w:gz', format=tarfile.GNU_FORMAT) as patch_archive:
            patch_archive.add(delta_target_dir, arcname=self.PATCH_FOLDER)

            if metadata:
                print("Adding metadata (.info)")
                patch_archive.add(metadata, arcname=self.METADATA_FILE)

        print("Cleaning up...")
        rmtree(target_dir)

        print("Done")

    def remove_deleted_items(self, target_dir, diff):
        deleted_items = diff.right_only

        for deleted_item in deleted_items:
            deleted_item_path = path.join(target_dir, deleted_item)
            if path.isdir(deleted_item_path):
                rmtree(deleted_item_path)
            else:
                remove(deleted_item_path)

            if self.args.debug: print("Deleted old path", deleted_file)

        for subdir, subdir_diff in zip(diff.common_dirs, diff.subdirs.values()):
            print(subdir)

            self.remove_deleted_items(path.join(target_dir, subdir), subdir_diff)

    # TODO: Unit test me
    def apply(self, old_dir, patch_bundle, target_dir, root_patch_dir = None):
        # Create a temp dir
        # TODO: Pass on the staging dir to apply
        patch_dir = self._get_temp_dir(None, 'delta_src')
        print("Using %s as staging area" % patch_dir)

        print("Extracting archive...")
        archive_object = XDelta3DirPatcher.get_archive_instance(patch_bundle)
        for filename in archive_object.list_files():
            archive_object.expand(filename, patch_dir)

        delta_patch_dir = path.join(patch_dir, self.PATCH_FOLDER)

        # If we want to apply only a part of the xdelta files (or a specific dir)
        if root_patch_dir:
            delta_patch_dir = path.join(delta_patch_dir, root_patch_dir)

        # Make target dir if we don't have one
        if not path.isdir(target_dir):
            print("WARNING: Target directory not present so it will be created.")
            print("  - Please ensure that the toplevel target dir has the correct permissions.")
            makedirs(target_dir)

        print("Removing deleted files")
        diff = dircmp(delta_patch_dir, target_dir, ignore = None)
        self.remove_deleted_items(target_dir, diff)

        print("Applying patches")
        for root, patch_dirs, patch_files in walk(delta_patch_dir):
            print("Entering directory", root)

            rel_path = path.relpath(root, delta_patch_dir)

            if self.args.debug: print("- Subdirs:", patch_dirs)
            if self.args.debug: print("- Files:", patch_files)

            for patch_dir1 in patch_dirs:
                self._apply_file_delta(rel_path, patch_dir1, old_dir, delta_patch_dir, target_dir)
            for patch_file in patch_files:
                self._apply_file_delta(rel_path, patch_file, old_dir, delta_patch_dir, target_dir)

            print("Leaving directory", root)

        print("Cleaning up...")
        rmtree(patch_dir)

        print("Done")

    @staticmethod
    def check_euid(ignore_euid, get_euid_method = geteuid):
        if (not ignore_euid) and get_euid_method() != 0:
            stderr.write("ERROR: You must be root to apply the delta! Exiting.\n")
            raise Exception()

    @staticmethod
    def get_random_string(length = 10):
        return ''.join([random.choice('0123456789ABCDEF') for i in range(length)])

    @staticmethod
    def get_archive_instance(archive_path):
        # TODO: Have a dynamic list of implementations to loop over

        # Ordering is important here since other impl classes error out on
        # directory paths
        if path.isdir(archive_path):
            return XDelta3FsImpl(archive_path)

        if tarfile.is_tarfile(archive_path):
            return XDelta3TarImpl(archive_path)
        if zipfile.is_zipfile(archive_path):
            return XDelta3ZipImpl(archive_path)

        raise RuntimeError('Error! Archive %s bad or not supported!' % archive_path)

    @classmethod
    def expand_archive(clazz, archive, staging_dir = None):
        # Figure out where to expand the archive
        expansion_dir = XDelta3DirPatcher._get_temp_dir(staging_dir, 'archive')
        print("Expanding %s into %s" % (path.basename(archive), expansion_dir))

        archive_object = XDelta3DirPatcher.get_archive_instance(archive)
        for filename in archive_object.list_files():
            archive_object.expand(filename, expansion_dir)

        return expansion_dir

    def run(self):
        print("Running directory patcher...")

        if self.args.action == 'diff':
            if self.args.debug: print("Parsing arguments")

            print("Generating delta pack")
            self.diff(self.args.old_version,
                      self.args.new_version,
                      self.args.patch_bundle,
                      self.args.metadata,
                      self.args.staging_dir)
        else:
            # If we're not the root user, bail since we can't ensure that the
            # user and group permissions are retained
            self.check_euid(self.args.ignore_euid)

            # If no target dir specified, assume in-place update
            if not self.args.target_dir:
                self.args.target_dir = self.args.old_dir

            print("Applying delta pack")
            self.apply(self.args.old_dir, self.args.patch_bundle, self.args.target_dir, self.args.root_patch_dir)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Creates and applies XDelta3-based directory diff tgz files')

    subparsers = parser.add_subparsers(dest='action')
    parser_apply = subparsers.add_parser('apply',
            help='Apply a diff from a directory. See "apply -help" for more options')

    parser_diff = subparsers.add_parser('diff',
            help='Generate a diff from directories/files. See "diff -help" for more options')

    # Arguments to apply a diff
    parser_apply.add_argument('old_dir',
            help='Folder containing the old version of the files')

    parser_apply.add_argument('patch_bundle',
            help='File containing the patches')

    parser_apply.add_argument('target_dir',
            nargs='?',
            default=None,
            help='Destination folder for the new versions of files')

    parser_apply.add_argument('-d', '--root-patch-dir',
            nargs='?',
            default=None,
            help='Root directory from the diff bundle from where to apply \
                  the patches')

    parser_apply.add_argument('--ignore-euid',
            help='Disable checking of EUID on applying the patch',
            default=False,
            action='store_true')

    # Arguments to create a diff
    parser_diff.add_argument('-m', '--metadata',
            nargs='?',
            default=None,
            help='Add this file (renamed to .info) as metadata to the diff')

    parser_diff.add_argument('-s', '--staging-dir',
            nargs='?',
            default=None,
            help='Use this directory for all staging output of this program. Defaults to /tmp.')

    parser_diff.add_argument('old_version',
            help='Folder or tgz containing the old version of the files')

    parser_diff.add_argument('new_version',
            help='Folder or tgz containing the new version of the files')

    parser_diff.add_argument('patch_bundle',
            help='Destination path for the generated patch diff')

    # Generic arguments
    parser.add_argument('--debug',
            help='Enable debugging output',
            action='store_true')

    parser.add_argument('--version',
            action='version',
            version='%(prog)s v' + VERSION)

    args = AttributeDict(vars(parser.parse_args()))

    if args.action:
        XDelta3DirPatcher(args).run()
    else:
        parser.print_help()
